## 객체를 어디까지 포장할까?

### 객체를 포장한다는 것은 무엇을 의미할까?

- Wrapper Class
    - 일반적으로 알고있는 Wrapper Class가 객체를 포장한 대표적인 예
        - 원시타입을 객체처럼 사용하기 위해 해당 원시타입의 변수와 값을 가지는 객체를 말한다.
            - 굳이 왜 원시타입을 포장하는 클래스를 만들었을까?
                - 기본적으로 원시타입은 객체가 아니다.
                - 원시타입을 객체로 변환시켜줘야하는 상황이 발생할 수 있다.
                - 이를 위해 Wrapper Class를 두어 쉽게 객체로(또는 다시 원시타입) 변환시킬 수 있다.
                - 형변환 시 쉽게 할 수 있는 메서드를 제공

---

- 일급 컬렉션
    - Collection 객체를 필드로 두고 있는 사용자 정의 클래스
    - 자료구조를 한번 감싼 클래스라고 말할 수 있다. (필드는 해당 자료구조외 존재하지 않는다.)
    - 일급 컬렉션은 왜 쓸까?
        - 해당 자료구조를 날 것(?)으로 사용할 시 확인해줘야하는 유효성 검사가 있을 수 있다.
            - 그렇다면 해당 자료구조를 사용하려할 때마다 유효성 검사를 해줘야하는 번거로움이 있다.
            - 이를 객체로 포장하여 객체에게 해당 로직을 위임하여 코드를 깔끔하게 분리할 수 있다.
        - 비지니스 로직에 종속적인 Collection(자료구조)를 맘 편히 둘 수 있다.
            - 유효성 검사와 비슷한 맥락으로 `List<Integer>` 를 필드로 두는 클래스가 있다면 이 자료구조에서 특정 조건에 맞는 원소 하나를 추출해야하는 로직이 필요할 때 일급 컬랙션 클래스에게 이 역할을 위임할 수 있다.

                    public class Line {
                    	private List<Point> points;
                    
                    	public int findRoute(int startPosition) {
                          if (hasBridgeAtLeftSide(startPosition + 1)) {
                              return LEFT_MOVE;
                          }
                          if (hasBridgeAtRightSide(startPosition)) {
                              return RIGHT_MOVE;
                          }
                          return NOT_MOVE;
                       }
                    }

---

- VO
    - Value Object (값 객체)
    - 식별자가 없는 작은 엔티티다.

        식별자 (Identity) : OOP에서 다른 객체들과 구분지을 수 있는 객체 속성 값

    - 자바에서 모든 커스텀 타입은 참조 타입이다. 그래서 아무리 커스텀한 값의 객체가 고려되더라도 식별자와 참조적 의미를 가지고 있다. 그렇다면 이는 다른 객체들과 다를게 없다. C#, C++과 달리 커스텀한 타입을 설정하지 못하기 때문에 불변 객체를 만들어 값 객체를 흉내낸다. 만약 객체의 상태가 변하지 않는다면 참조 값을 전달하는 것이 의미적으로 값 객체 자체를 복사하는 행위와 동일하기 때문에 이것이 가능하다.

---

- 불변 객체
    - 인스턴스의 내부 값을 수정할 수 없는 클래스
        - 객체가 파괴되는 순간까지 내부 정보는 절대 달라지지 않는다.
    - 클래스를 불변으로 만들면 이를 활용한 설계 및 구현이 쉬우며 오류가 발생할 여지도 줄어든다.
    - 근본적으로 불변 객체는 스레드 안전하다.
    - 불변이 보장되면 캐싱할 수 있다.
        - 빈번히 사용될 인스턴스를 미리 생성해놓고 요청 시 해당 인스턴스를 반환해주면 되기 때문이다.
