# 레벨 1 미션 피드백

### 레이싱 카
1. CarGenerator 클래스가 cars를 멤버로 가지지 않아도 된다.
    * CarGenerator 객체의 역할은 Car 객체를 생성하는 것이다!
    * 객체의 역할을 잘 구분하자~
2. 인스턴스 메서드와 클래스 메서드
3. CarNames를 클래스화(일급 컬렉션)하여 얻은 장점은 무엇이었나?
    * 예외가 발생할 확률이 높은 사용자 입력 데이터를 처리하는 부분이 분리되어 경우를 관리하기가 편리하다
4. 프로덕션용 메서드와 테스트용 메서드를 분리하여 작성하지 말라.
    * 동일한 로직을 갖고 있더라도 다른 메서드는 다른 것이라 테스트의 의미가 퇴색된다.
    * void 반환 형식의 메서드보다 반환값이 있는 것이 더 좋은 경우가 많다.
5. 패턴은 패턴일 뿐 중요한 것은 객체를 분리하는 것이다. 어떤 체계를 시스템으로 만들 때 어떤 것들을 객체로 추출해서 정의할 것인지가 최우선이다!
6. 객체지향에서 `getter/setter`는 지양한다. 객체에게 메시지를 던지자.
    * 왜?
        - 다른 객체의 상태를 직접 이용한다는 것은 객체끼리의 협력이 적극적으로 이루어지지 못하고 있다는 것을 의미하지 않을까
        - 현실 세계로 친다면, 서브웨이에서 손님인 나는 샌드위치의 재료를 주문해야 되는데 샌드위치에 필요한 재료를 손수 가져가는 꼴인 것이지
        - 민증


### 사다리게임
1. 객체가 너무 많은 책임을 갖고 있다.
2. e.printStackTrace는 안티패턴이다. <u>리플렉션 기반으로 추적하기 때문에 성능에 이슈</u> 도 있다. (구뤵?)
    - 커스텀 예외를 던질 때 발생했던 예외를 함께 던지지 않는 경우
    
    - 발생했던 예외를 담아서 던지는 경우 => 예외의 원인을 알 수 있다!
￼
3. `ArrayList<List<Boolean>>` -> `List`가 표현하고 있는 의미가 있다면 객체로 만들어서 표현하라. (일급 컬렉션)
    - 값의 의미를 부여함으로써 의도를 명확하게 전달한다.
4. 강한 의존성은 OCP와 DIP에 위반한다. 어떤 Generator를 쓸 지는 외부에서 주입받아 사용하라.
    * 어떤 코드였길래…?
        * 메서드 안에서 Generator 생성자를 직접 호출하여 Ladder 객체의 lines에 add하는 상황이었다~
￼
    * 이렇게 하면(의존성이 위험한 이유) 안 좋은 점이 뭐였길래?
        - `RandomLineGenerator`를 변경하면 `Ladder` 객체도 변경된다.
            - 하나의 모듈이 바뀌면 의존한 다른 모듈까지 변경된다.
        - 랜덤값을 반환하는 `RandomLineGenerator`에 의존하면 상황을 예측할 수 없어서 로직을 테스트하기 어렵다.
    * 테스트용 생성자가 아닌 실제 로직과 똑같은 생성자를 통해 객체를 사용할 수 있다.
5. 결합도는 너무 크고 응집도는 너무 낮다😥


### 좌표계산기
1. implements와 extends를 처음으로 구별할 줄 알게 됨
2. 정적 팩토리 메서드를 사용해야 하는 때를 잘 구분해서 사용하라.
    1. 팩토리 패턴
    2. 팩토리 메서드 패턴 (`(i)LadderGenerator` -> (`RandomLadderGenerator`, `ManualLadderGenerator`))
    3. 정적 팩토리 메서드
3. 상태를 가지는 객체의 데이터를 꺼내려(get)하지 말고 객체에 메시지를 보내라는 원칙에 따라 구현한다.
4. 중복 코드들은 부모 객체로 추상 클래스에 추가해 제거할 수 있다.
5. 원시 값을 객체로 포장할 경우 성능이 떨어질 수 있으니 (무조건적인 불변인 것이 전제로) 인스턴스를 캐싱해서 재사용 가능한 구조로 개발해보자.
6. BigDecimal
    - double은 부동소수점을 이진법으로 나타내기 때문에 정확한 값을 저장할 수 없다.
    - BigDecimal 클래스를 사용하여 정확한 계산을 하자~


### 로또
1. 숫자 리터럴에 언더바(_)를 사용하여 단위를 구분할 수 있다.
2. 상수를 활용하자~
3. 범위 테스트를 진행할 때는 경계값을 기준으로 테스트 하자~
4. 공통적인 부분을 인터페이스로 추출해보자~
    * 이점이 뭐길래?
5. 서비스 레이어를 이용하자
    * 서비스의 역할이 무엇이냐
        * 컨트롤러와 DAO 사이에서 실질적인 비즈니스 로직을 담당하는 계층

* 깨달은 것
    * 프로그램이 반드시 필요한 기능부터 구현하고 사욕을 채우자
    * 설계..어렵다
    * 고민만 하지 말고 우선 구현부터 해보고 리팩토링 하면서 고쳐나가자


### 체스
1. 디미터 원칙을 지켜라.
2. Stream API의 foreach는 결과를 출력하는 용도로만 사용하자. 오히려 가독성이 떨어지고, OOP와 멀어질 수 있다.
    - foreach는 종단 연산자이기 때문에 어떻게 보면 결과를 도출하는 역할만 하기 때문에 -> **찾아보죠?**
3. 클래스 내 메서드 순서 컨벤션이 있으니 참고하라.
    * public -> protected -> private
    1. 클래스 변수
    2. 인스턴스 변수
    3. 생성자
    4. 메서드: 스코프나 접근 제어자를 기준으로 하기보다는 기능적으로 우선 묶는다.
    * 참조: https://stackoverflow.com/questions/4668218/are-there-any-java-method-ordering-conventions
