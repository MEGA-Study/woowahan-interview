## AOP

> Aspect-oriented Programming

관점 지향 프로그래밍이다.

AOP가 쓰이는 대표적인 사례는 트랜잭션이다.

## 트랜잭션 서비스 추상화

트랜잭션이라는 기능은 비지니스 로직과는 성격이 다르기 때문에 같은 곳에 위치할 필요가 없다.

 비지니스 로직과 트랜잭션 로직이 같이 있는 곳은 특정 트랜잭션 기술에 종속되는 코드가 되어버리기 때문이다.

→ JDBC 로컬 트랜잭션 방식을 JTA를 이용한 분산 트랜잭션 방식으로 바꾸면 트랜잭션 로직이 있는 모든 곳에 변경이 일어난다.

그래서 스프링에서는 트랜잭션 관리를 위한 추상화된 객체를 제공한다. `PlatformTransactionManager`

## 프록시와 데코레이터 패턴

![1_decorate_pattern](https://user-images.githubusercontent.com/30451129/67537607-234bf600-f717-11e9-99e3-5594b4682d10.jpeg)

- 핵심기능 (비지니스 로직) 과 부가기능 (트랜잭션)은 위와 같이 분리할 수 있다.
- 여기서 핵심은 비지니스 로직은 부가기능 클래스에 전혀 없어야된다는 점이다.
- 핵심기능 클래스에게 해당 기능 역할을 위임하면서 핵심 기능 클래스는 부가기능 클래스의 존재를 모르게 만들어준다.

부가기능와 핵심기능을 분리했어도 클라이언트가 핵심기능을 직접 사용해버린다면 부가기능이 전혀 적용되지 않는 기능을 사용하게 된다. 이렇게 분리한 의미가 없어진다.

![2_decorate_pattern](https://user-images.githubusercontent.com/30451129/67537611-28a94080-f717-11e9-9040-f03246d58bc7.jpeg)

- 클라이언트 입장에서는 인터페이스를 통해 핵심기능을 사용하려 하기 때문에 부가기능이 그 사이에 끼어들어 클라이언트는 핵심기능을 사용하는 것 같지만 사실은 부가기능을 사용하는 구조로 만들어준다.
- 여기서 클라이언트에게 핵심기능인척하고 부가기능을 첨가한 로직을 수행하는 것을 대리자, 대리인의 역할을 하는 **프록시(proxy)**라고 한다.
- 프록시를 통해 실제 핵심기능을 처리하는 클래스, 오브젝트를 타깃(target) 또는 실체(real subject)라고 한다.

## 프록시 패턴

일반적으로 사용하는 프록시라는 용어는 디자인 패턴에서 말하는 프록시 패턴의 프록시와 구분지을 필요가 있다.

전자는 클라이언트와 타깃 사이에 대리 역할을 하는 모든 오브젝트를 말한다.

후자는 프록시를 사용하는 방법 중에서 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우를 가리킨다.

프록시 패턴의 프록시는 타깃의 기능을 확장하거나 추가하지 않는다. 

대신 클라이언트가 타깃에 접근하는 방식을 변경해준다.

타깃 오브젝트를 생성하는데 비용이 많이 들거나 복잡하다면 당장 필요한 시점까지 생성하지 않고 클라이언트에게 프록시를 넘겨주는 것이다.

프록시 메서드를 통해 타깃 오브젝트에 접근하려한다면 그때 프록시가 타깃 오브젝트를 생성하고 해당 요청을 위임하는 식으로 처리한다.

  ex) Collections.unmodifiableCollection()

이렇게 프록시 패턴은 타깃의 기능 자체에는 관여하지 않으면서 접근하는 방법을 제어해주는 프록시를 이용하는 것을 말한다.

## 다이내믹 프록시

프록시는 만들기 번거롭다

- 타깃 인터페이스를 구현하고 위임하는 코드를 작성하기가 상당히 귀찮은 일이다.
    - 부가기능이 필요없는 메서드에 대해서도 구현해야한다.
    - 인터페이스의 메서드가 많으면 더 골치아프다.
- 부가기능이 중복이 일어날 수 있다. (특히 트랜잭션은 더욱더 코드의 변화가 없다)

![3_dynamic_proxy](https://user-images.githubusercontent.com/30451129/67537615-2b0b9a80-f717-11e9-8549-35a1370b754e.jpeg)

- 다이내믹 프록시는 프록시 팩토리에 의해 런타임 시 생성되는 오브젝트다.
- 이를 이용하면 프록시 생성의 번거로움을 제거할 수 있다.
    - 프록시 팩터리에게 구현해야할 인터페이스의 정보만 제공해주면 이를 구현한 오브젝트를 자동으로 만들어준다.

        → 인터페이스의 메서드가 많아도 이젠 상관없다.

    - 부가기능은 *`InvocationHandler`* 에 구현해준다.
        - 다이나믹 프록시로부터 실행해야할 메서드 정보를 받아서 처리한다.
        - *`InvocationHandler`* 에는 유일하게 있는 `invoke()` 메서드만 구현해주면 된다.

            → 부가기능에 중복을 없애준다.

![4_dynamic_pattern](https://user-images.githubusercontent.com/30451129/67537618-2e068b00-f717-11e9-8e51-e6b050e6e371.jpeg)

- 다이나믹 프록시를 생성해주는 로직이다.

![5_dynamic_proxy](https://user-images.githubusercontent.com/30451129/67537621-3068e500-f717-11e9-9ceb-933c9936879a.jpeg)

- 다이내믹 프록시를 사용했을 때 구조

## 팩토리 빈

`Proxy` 클래스의 `newProxyInstance()` 는 정적 팩토리 메서드이므로 일반적인 방법으로 스프링의 빈 등록이 불가하다. 그래서 스프링이 제공하는 `FactoryBean<>` 구현하는 팩토리 빈을 스프링 빈으로 등록해준다. 이 팩토리 빈은 이름 그대로 빈을 생성해주는 빈이다. `Proxy` 클래스의 다이내믹 프록시를 생성해주는 메서드가 스태틱이라서 바로 빈으로 등록하지 못하는 클래스에 대해 빈 등록을 가능케 해준다.

## 프록시 팩토리 빈의 한계

- 위와 같은 방식으로는 여러 개의 클래스에 공통적인 부가기능을 제공하는 것이 불가능하다.
    - 타깃에 부가기능을 제공하는 것은 메서드 단위로 일어난다.

        → 결국 타깃과 인터페이스만 다른 거의 비슷한 설정이 자꾸 반복하게 된다.

- 부가기능을 적용하는 코드의 중복을 제거해줬던 *`InvocationHandler*` 는 오브젝트가 프록시 팩토리 빈 개수만큼 만들어진다. *`InvocationHandler`* 는 타깃 오브젝트를 프로퍼티로 가지고 있어 타깃이 다르다면 새롭게 생성해줘야한다. → 싱글톤으로 적용할 필요가 있다.

## 스프링의 ProxyFactoryBean

![6_proxy_factory_bean](https://user-images.githubusercontent.com/30451129/67537623-319a1200-f717-11e9-9ea3-48ee93a29dab.jpeg)

프록시를 생성해서 빈 오브젝트로 등록하게 해주는 팩토리 빈이다.

`ProxyFactoryBean`은 기본적으로 JDK가 제공하는 다이내믹 프록시를 만들어준다. 경우에 따라서 CGLib 프레임워크를 이용해서 프록시를 만들기도 한다.

`ProxyFactoryBean` 에서 생성되는 프록시에 사용될 부가기능은 *`MethodInterceptor*` 인터페이스를 구현해서 만든다.

- *`MethodInterceptor`* 는 *`InvocationHandler*`와 비슷하지만 다른 한 가지는 타깃 오브젝트의 정보를 인자로 제공받는다는 점이다.
- *`InvocationHandler`* 는 타깃 정보를 메서드인 `invoke()`로 제공받지 않아 구현체가 필드로 참조하고 있어야하는 반면 *`MethodInterceptor`* 의 메서드 `proceed()` 는 `ProxyFactoryBean` 로부터 타깃 오브젝트에 대한 정보까지 함께 제공받는다.
- 그래서 타깃 오브젝트의 종류에 종속적이지 않아 싱글톤으로 유지할 수 있다.

*`MethodInterceptor`* 의 메서드 `proceed()` 는 *`MethodInvocation`* 를 인자로 받는다.

- 이는 일종의 콜백 오브젝트로 `proceed()` 메서드가 실행되면 타깃 오브젝트의 메서드를 실행시켜주는 기능이 있다.
- *`MethodInvocation`* 의 구현 클래스는 일종의 공유 가능한 템플릿처럼 동작하는 것이다.
- 이는 `JdbcTemplate` 의 종속적인 요소를 제거하여 싱글톤으로 유지되어 여러 DAO가 공유할 수 있는 구조와 같은 상황이다.

## 어드바이스

타깃이 필요 없는 순수한 부가기능

→ 타킷 오브젝트에 종속되지 않는 순수한 부가기능을 담은 오브젝트다.

위 *`MethodInterceptor`* 를 구현한 구체 (부가기능) 오브젝트를 스프링에서는 어드바이스라고 부른다.

## 포인트컷

부가기능 적용 대상 메서드 선정 방법 (메서드 선정 알고리즘)

## 어드바이저

어드바이스와 포인트컷을 묶은 오브젝트를 말한다.

![7_proxy_factory_bean_structure](https://user-images.githubusercontent.com/30451129/67537624-3363d580-f717-11e9-97c1-b877c8eb9c7a.jpeg)

## 자동 프록시 생성기

위와 같은 구조로 비지니스 로직에 반복적으로 등장했던 트랜잭션 코드를 깔끔하고 효과적으로 분리해냈다.

부가기능 적용과 타깃에 대한 프록시 생성은 코드 생성 기법을 이용하는 다이내믹 프록시 기술에 맡기고 변하는 부가기능은 별도로 만들어 프록시 생성 팩토리에 DI로 제공하는 방법을 사용한다.

하지만 위 그림과 같이 타깃마다 `ProxyFactoryBean` 빈 설정정보를 추가해줘야한다.

그래서 스프링에서는 `DefaultAdvisorAutoProxyCreator` 라는 빈 후 처리기를 제공한다. 이것이 빈으로 등록되어있으면 빈으로 등록되는 오브젝트가 빈으로 등록된 모든 어드바이저 내의 포인트컷을 이용해 프록시 적용대상인지 확인한다. 적용 대상이라면 내장된 프록시 생성기에게 해당 오브젝트의 프록시를 만들게 하고 만들어진 프록시에 어드바이저를 연결해주어 컨테이너에게 전달해준다. 컨테이너는 해당 오브젝트가 빈으로 등록이 요청됐지만 최종적으로는 빈 후처리기가 반환해준 빈을 등록하고 사용한다.

> 포인트컷에는 클래스 필터와 메서드 매처 메서드가 있다.

## 부가기능의 모듈화

소프트웨어 개발의 가장 기본이 되는 원칙 중 하나는 '관심사 같은 코드끼리 잘게 쪼개서 한데 모아 관리하는 것'이다.

그러나 트랜잭션과 같은 부가기능은 핵심기능옆에 붙어서 그 기능을 보완하는 등의 방식으로 존재 가치를 실현한다. 이러한 부가기능을 따로 한데 모아 관리하게 된다면 그 가치를 바로 잃어버리게 된다. 즉, 트랜잭션과 같은 부가기능은 위에서 언급한 소프트웨어 개발 원칙을 적용하기 어려운 존재라는 말이다.

**일반적인 방법으로 모듈화시키기 어려운 부가기능을 모듈화 시키기위한 프로그래밍 기법이 AOP다.**

## AOP : 애스펙트 지향 프로그래밍

OOP의 클래스가 있다면 AOP에는 애스펙트가 있다.

애스펙트란 그 자체로 어플리케이션의 핵심기능을 담당하고 있지 않지만 어플리케이션을 구성하는 중요한 한 요소이고, 핵심기능에 부가되어 의미를 갖는 특별한 모듈을 말한다.

위 모든 과정을 밟아온게 애스펙트라는 독특한 녀석을 어플리케이션의 핵심기능으로부터 분리시키기 위함이다. 정리하자만 **AOP란 프로그램 전체에 분산되어 있는 부가기능을 핵심기능으로부터 분리하여 한데 모아 애스펙트라고 불릴 수 있는 모듈화 작업을 통해 설계하고 개발하는 방법을 이야기한다.**

## AOP 기술

### 프록시를 이용한 AOP

스프링은 IoC/DI 컨테이너, 다이나믹 프록시, 데코레이터 / 프록시 패턴, 자동 프록시 생성 기법, 빈 오브젝트 후처리 기법을 이용한 AOP를 지원하고 있다. 핵심은 프록시를 이용했다는 것이다.

프록시를 만들어서 DI로 연결된 빈 사이에 끼어들어 메서드 호출과정에 부가기능을 첨가하여 제공해주도록 만들어졌다.

이 프록시는 독립적으로 개발한 부가기능 모듈을 다양한 타킷 오브젝트의 메서드에 동적으로 적용시켜줄 수 있게 해주는 가장 중요한 역할을 한다. 그래서 스프링 AOP는 프록시 방식의 AOP라고 할 수 있다.

### 바이트코드 생성과 조작을 통한 AOP

AOP 프레임워크 중 하나인 AspectJ는 프록시를 사용하지 않는다.

AspectJ는 아예 타깃 오브젝트를 뜯어고쳐서 부가기능을 넣어주는 방식을 사용한다. 컴파일된 타깃 클래스 파일 자체를 수정하거나 클래스가 JVM에 로딩되는 시점을 가로채서 바이트코드를 조작하는 복잡한 방법을 사용한다.

- 이는 스프링 AOP와 같이 프록시 생성을 위한 DI 컨테이너의 존재도 필요없이 AOP를 적용할 수 있다는 장점이 있다.
- 그리고 프록시 기반 AOP 메커니즘은 그 대상은 결국 메서드에 한정된다. 하지만 바이트코드를 직접 조작하는 방법을 통해 접근 제어자 상관없이 오브젝트 생성, 필드 값 조회, 조작, 스태틱 초기화 등 다양한 작업에 부가기능을 추가해줄 수 있다.

### 프록시의 종류

스프링 AOP의 프록시는 두가지 종류가 있다. 하나는 JDK의 다이나믹 프록시이고 하나는 CGLib를 이용한 프록시다.

**JDK 다이나믹 프록시**

JDK 다이나믹 프록시는 인터페이스를 이용하여 구현하는 프록시다. 원래 프록시의 원리인 데코레이터 패턴과 DI를 이용해야하기 때문에 인터페이스 기반으로 만들어졌다. 

이 말은 JDK 다이나믹 프록시는 타깃 오브젝트가 인터페이스를 구현하고 있어야 만들어질 수 있다는 말이다.

**CGLib를 이용한 프록시**

프록시 객체 생성을 위해 항상 인터페이스를 둬야하는 제약사항을 탈피하기 위해 인터페이스 구현이 없는 타깃인 경우는 CGLib 라이브러리를 이용한 클래스 프록시를 만든다.

타깃 클래스를 상속하는 서브 클래스를 만들어서 이를 프록시로 사용한다. 이는 프록시를 만들기 위해 클래스를 상속하고 상속받은 public 메서드를 모두 오버라이드해서 프록시 기능으로 바꿔치는 방식이다.

> 단 이와 같은 방식은 클래스와 메서드에 final이 적용되면 안된다. → 상속이 안되기 때문
